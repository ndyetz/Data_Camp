---
title: "Network Science in R - A Tidy Approach"
subtitle: Lessons from DataCamp
output:
  pdf_document:
    toc: yes
    toc_depth: 3
  html_notebook:
    toc: yes
    toc_float: true
  html_document:
    toc: yes
    toc_float: true
---

#Introduction

The following document outlines the written portion of the lessons from [DataCamp](https://www.datacamp.com/)'s [Network Science in R - A Tidy Approach](https://www.datacamp.com/courses/network-science-in-r-a-tidy-approach). This requires Intermediate R-Knowledge and knowledge of the Tidyverse package. 

As a note: All text is completely copied and pasted from the course. There are instances where the document refers to the "editor on the right", please note, that in this notebook document all of the instances are noted in the "r-chunks" (areas containing working r-code), which occurs below the text, rather than to the right. Furthermore, This lesson contained instructional videos at the beginning of new concepts that are not detailed in this document. However, even without these videos, the instructions are quite clear in indicating what the code is accomplishing. 

<u>*If you have this document open on "R-Notebook", simply click "run" -> "Run all" (Or just press 'ctrl + alt + r'), let the "r-chunks" run (This might take a bit of time) then click "Preview". There are 5 necessary datasets to run this program, please create an r-project with this data or set a working directory (required files names are available in the "Required data for this session" section)*</u>

This document was created by Neil Yetz on 05/19/2018. Please send any questions or concerns in this document to Neil at <ndyetz@gmail.com>



##Required packages for this session

Below are the install.packages and libraries you will need to have in order to run this session successfully.

```{r, message = FALSE}
#install.packages("readr")
#install.packages("igraph")
#install.packages("ggraph")
#install.packages("visNetwork")

library(readr)
library(igraph)
library(dplyr)
library(ggplot2)
library(ggraph)
library(visNetwork)
```

##Required data for this session

```{r, message = FALSE}

#nodes  <- read_csv("nodes.csv")
#ties   <- read_csv("ties.csv")
```

#Course Description

If you've ever wanted to understand more about social networks, information networks, or even the neural networks of our brains, then you need to know network science! It will demonstrate network analysis using several R packages, including dplyr, ggplot2, igraph, ggraph as well as visNetwork. You will take on the role of Interpol Analyst and investigate the terrorist network behind the Madrid train bombing in 2004. Following the course, you will be able to analyse any network with basic centrality and similarity measures and create beautiful and interactive network visualizations.

#Chapter 1: The hubs of the network

The challenge in this chapter is to spot the most highly connected terrorists in the network. We will first import the dataset and build the network. Then we will learn how to visualize it in different layouts using ggraph package. Later on, we will compute two basic yet important centrality measures in network science - degree and strength. We will use them to spot highly connected terrorists. We will finally touch two alternative centrality measures, betweenness and closeness.

##Explore the dataset

In this first exercise, you will explore the dataset. You will use the package `readr` to read the `nodes` and `ties` datasets from CSV files into variables in R. For your convenience, the package readr is already loaded into the workspace.

INSTRUCTIONS

Read the `nodes` and `ties` into variables with the `read_csv()` function.
Print nodesand then ties to explore the nodes and ties in the console. How many nodes and ties are in the dataset?

```{r}
# read the nodes file into the variable nodes
nodes <- read_csv("nodes.csv")

# read the ties file into the variable ties
ties <- read_csv("ties.csv")

# print nodes
nodes

# print ties
ties
```

##Build and explore the network (part 1)

In this exercise, you are going to begin using the `igraph` package. This package lets you analyze data that are represented as networks, which are also called graphs by mathematicians. In particular, you will learn how to build a network from a data frame and explore the nodes and ties of the network.

For your convenience, the package `igraph` and the data frames nodes and ties are already loaded into the workspace.

INSTRUCTIONS

Use `graph_from_data_frame()` to build a network from the data frame ties and save it as `g`. Print the network to discover the number of nodes and ties.

Explore the nodes in `g` with `V()` and print the number of nodes with `vcount()`

Explore the ties in `g` with `E()` and print the number of ties with `ecount()`

```{r}
# make the network from the data frame ties and print it
g <- graph_from_data_frame(ties, directed = FALSE, vertices = nodes)
g

# explore the set of nodes
V(g)

# print the number of nodes
vcount(g)

# explore the set of ties
E(g)

# print the number of ties
ecount(g)
```

##Build and explore the network (part 2)

A network built using `igraph` can have attributes. These include:

- Network attributes: properties of the entire network

- Node attributes: properties of nodes

- Tie attributes: properties of ties

In this exercise, we will explore all these types of attributes.

`igraph` and the variable `g` containing the network are already loaded into the workspace.

INSTRUCTIONS

Give the name "Madrid network" to the network. Then print the network name attribute.

Add node attribute `id` and set the id numbers from 1 to the number of nodes of the network. Then print the `id `attribute.

Print the tie `weight` attribute.

Print the network. Can you spot the different types of attributes?

```{r}
# give the name "Madrid network" to the network and print the network `name` attribute
g$name <- "Madrid network"
g$name

# add node attribute id and print the node `id` attribute
V(g)$id <- c(1:length(V(g)))
V(g)$id

# print the tie `weight` attribute
E(g)$weight

# print the network and spot the attributes
g
```

##Visualize the network (part 1)

Welcome to the `ggraph` package! In this course, we will use this package to visualize networks.

The package `ggraph` extends `ggplot2` by using geometries to visualize the nodes (`geom_node_point`) and ties (`geom_edge_link`) of a network.

If you already know a bit of `ggplot2`, you will learn `ggraph` quickly! For your convenience, `ggraph` is already loaded into the workspace, the graph theme is set with the function `set_graph_style()`, and the variable `g` containing the network is at your disposal.

INSTRUCTIONS 1/2

Visualize the network with the Kamada-Kawai layout and set the transparency of ties (`alpha`) equal to weight. Can you visually spot the important nodes and ties?

```{r}
# visualize the network with layout Kamada-Kawai
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point()

```

INSTRUCTIONS 2/2

Add a label to the nodes that corresponds with their ids using the `geom_node_text()` geometry and make sure to prevent the labels from overlapping.

```{r}
# add an id label to nodes
ggraph(g, layout = "with_kk") +
  geom_edge_link(aes(alpha = weight)) +
  geom_node_point()  + 
  geom_node_text(aes(label = id), repel = TRUE)
```

##Visualize the network (part 2)

In the previous exercise, we used a force-directed layout (the Kamada-Kawai layout) to visualize the nodes and ties, in other words, it placed tied nodes at equal distances, so that all ties had roughly the same length.

In this exercise, we will use two alternative layouts: circle, which places nodes on a circle, and grid, which places nodes on a grid.

For your convenience, the variable `g` containing the network is at your disposal.

INSTRUCTIONS 1/2

Visualize the network with a circular layout. Set tie transparency proportional to weight.

```{r}
# visualize the network with circular layout. Set tie transparency proportional to its weight
ggraph(g, layout = "in_circle") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point()
```

INSTRUCTIONS 2/2

Visualize the network with a grid layout. Set tie transparency proportional to weight.

```{r}
# visualize the network with grid layout. Set tie transparency proportional to its weight
ggraph(g, layout = "grid") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point()
```

##Find the most connected terrorists

The challenge of this exercise is to spot the most connected terrorists of the train bombing network. We will take advantage of the most simple and popular centrality measure in network science: degree centrality.

You will use both `igraph` and `dplyr`, which are already loaded in the workspace. The variables `g`, which contains the network, and a data frame, `nodes`, which contains the nodes of the network are also pre-loaded.

Before starting, search on Wikipedia for `"Jamal Zougam"` to check whether he was involved in the bombings.

INSTRUCTIONS

Use `degree()` to compute the degrees of nodes and save them in a variable `dgr`.

Mutate the data frame `nodes`, add the `degree` variable, and set it to `dgr`.

Add a node attribute `degree` to the network using the variable `dgr`.

Arrange the terrorists in the `nodes` data frame in decreasing order of degree.

```{r}
# compute the degrees of the nodes
dgr <- degree(g)

# add the degrees to the data frame object
nodes <- mutate(nodes, degree = dgr)

# add the degrees to the network object
V(g)$degree <- dgr

# arrange the terrorists in decreasing order of degree
arrange(nodes, -degree)
```

##Find the most strongly connected terrorists

The challenge in this exercise is to spot the most strongly connected terrorists of the train bombing network. We will exploit another centrality measure in network science: strength centrality.

Again, you will take advantage of `igraph` and `dplyr`, which are already loaded in the workspace. The variable `g`, which contains the network, and the data frame nodes, which contains the nodes of the network are at your disposal.

INSTRUCTIONS

Use `strength()` to compute the strength of the nodes.

Mutate the data frame `nodes`, add the `strength` variable, and set it to `stg`.

Add a node attribute, `strength`, to the network using the `stg` variable.

Arrange the terrorists in decreasing order of strength and degree. Do you notice any correlation between the two?

```{r}
# compute node strengths
stg <- strength(g)

# add strength to the data frame object
nodes <- mutate(nodes, strength = stg)

# add strength to the network object
V(g)$strength <- stg

# arrange terrorists in decreasing order of strength and then in decreasing order of degree
arrange(nodes, -strength)
arrange(nodes, -degree)
```


##More on centrality

There are other centrality measures, but covering them all is beyond the scope of this course. A couple other centrality measures include:

- Betweenness: a measure that quantifies how often a node lies on the shortest path between other nodes.

- Closeness: a measure that quantifies how close a node is to all other nodes in the network in terms of shortest path distance.

Use the console to read the R documentation for betweenness (type `?betweenness`) and find out how to determine the terrorist with the highest betweenness in the network.

The data frame `nodes` and the network `g` are loaded for you.

```{r}
betweenness(g)
```


INSTRUCTIONS

Possible Answers (Correct Answer is **Bolded**)

**Semaan Gaby Eid**

Mohamed Chaoui

Abdeluahid Berrak

Jamal Zougam




#Chapter 2: In its weakness lies its strength

In this chapter we will spot the most influential ties among terrorists in the network. We will use a centrality measure on ties, called betweenness, and will learn how to visualize the network highlighting connections with high betweenness centrality. Moreover, we will provide some alternative evidence regarding Mark Granovetter's theory of strength of weak ties, confirming that looser connections are crucial as demonstrated in the Madrid terrorism network.


##Betweenness of ties

Betweenness of ties is defined by the number of shortest paths going through a tie.

Ties with high betweenness may have considerable influence within a network by virtue of their control over information passing between nodes. They are also the ones whose removal will most disrupt communication between nodes.

We will compute a weighted version of betweenness, with tie weights inversely proportional to tie strength.

The network `g` and the data frame `ties` are at your disposal.

INSTRUCTIONS

Put the inverse of the tie weights in a variable called `dist_weight`.

Compute the weighted tie betweenness with `edge_betweenness()` and save it to `btw`.

Mutate the data frame `ties`, add the variable `betweenness`, and set it to `btw`.

Add the tie attribute `betweenness` to the network `g`.

```{r}
# save the inverse of tie weights as dist_weight
dist_weight <- 1 / E(g)$weight

# compute weighted tie betweenness
btw <- edge_betweenness(g, weights = dist_weight)

# mutate the data frame ties adding a variable betweenness using btw
ties <- mutate(ties, betweenness = btw)

# add the tie attribute betweenness to the network
E(g)$betweenness <- btw
```

##Find ties with high betweenness

In the tidy approach to network science, a network is represented with a pair of data frames: one for nodes and one for ties.

In this exercise, we will exploit the `dplyr` function `left_join()` to extract information from both the `nodes` and `ties` data frames. We need to use a join because the `ties` data frame contains the IDs of the terrorists, not their names, which are stored in the nodes data frame.

The data frames `nodes` and `ties` are already loaded in the workspace.

INSTRUCTIONS 1/3

Join the ties with the nodes using left_join (twice) to find the names of terrorists corresponding to the tied nodes.

```{r}
# join ties with nodes
ties_joined <- ties %>% 
  left_join(nodes, c("from" = "id")) %>% 
  left_join(nodes, c("to" = "id")) 

```

INSTRUCTIONS 2/3

Select only the relevant variables: `ids` and names of tied terrorists and betweenness.

```{r}
# select only relevant variables and save to ties
ties_selected <- ties_joined %>% 
  select(from, to, name_from = name.x, name_to = name.y, betweenness)
```

INSTRUCTIONS 3/3

Finally, arrange the ties in decreasing order of betweenness.

```{r}
# arrange named ties in decreasing order of betweenness
arrange(ties_selected, -betweenness)
```

##Visualize node centrality

In this exercise, you will use the `ggraph` package to visualize the network by making the node size proportional to its centrality (either degree or strength).

This is useful to visually spot the central nodes in the network. Are these nodes part of the central core or in the periphery?

The network `g` is already loaded in the workspace.

INSTRUCTIONS 1/2

Set network layout to Kamada-Kawai, the tie `alpha` to weight, and node `size` to degree.

```{r}
# set (alpha) proportional to weight and node size proportional to degree
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point(aes(size = degree))
```

INSTRUCTIONS 2/2

Produce the same visualization, but set node size proportional to strength.

```{r}
# produce the same visualization but set node size proportional to strength
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight)) + 
  geom_node_point(aes(size = strength))
```

##Visualize tie centrality

In this exercise, you will use the ggraph package again, but this time you will visualize the network by making tie size proportional to tie betweenness centrality.

Can you visually spot the central ties in the network topology? Recall that high betweenness ties typically act as bridges between different communities of the network.

Next, we will add degree centrality to visualize important nodes.

The network `g` is already loaded in the workspace.

INSTRUCTIONS 1/2

Use `ggraph` to visualize the network with the Kamada-Kawai layout (`"with_kk"`). Set the tie transparency using the `alpha` argument proportional to tie betweeness.

```{r}
# visualize the network with tie transparency proportional to betweenness
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = betweenness)) + 
  geom_node_point()
```


INSTRUCTIONS 2/2

Produce the same visualization with node size proportional to degree.

```{r}
# add node size proportional to degree
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = betweenness)) + 
  geom_node_point(aes(size = degree))
```


##Filter important ties

In this exercise, you will use the `ggraph` package once again, but this time we will filter out ties with small betweenness values and only include ties with a large value of betweenness (larger than the median). This will remove half of the ties from the visualization and leave only the important ties.

The network `g` is already loaded in the workspace.

INSTRUCTIONS

Find median betweenness using `median()`.

Use `ggraph` to visualize the network with only ties with betweenness larger than the median.

```{r}
# find median betweenness
q = median(E(g)$betweenness)

# filter ties with betweenness larger than the median
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = betweenness, filter = (betweenness > q))) + 
  geom_node_point() + 
  theme(legend.position="none")
```

##How many weak ties are there?

Recall that a weak tie as a tie with a weight equal to 1 (the minimum weight).

In this exercise, we are going to use the `dplyr` function `group_by()` to group ties by their weights and the `summarise()` function to count them. Hence, we are going to discover how many weak ties there are in the network.

The `ties` data frame is loaded in the workspace.

INSTRUCTIONS

Use `group_by()` to group ties by their weight.

Use `summarise()`, `n()`, and `nrow()` to find the total number of ties and calculate the percentage of weak ties.

Finally `arrange()` the groups by decreasing order of the number of ties.

```{r}
# find number and percentage of weak ties
ties %>%
  group_by(weight) %>%
  summarise(number = n(), percentage = number/nrow(ties)) %>%
  arrange(-number)
```


##Visualize the network highlighting weak ties

In this exercise, we use the `ggraph` package to visualize weak and strong ties in different colors. It is useful to have an immediate visual perception of the importance of weak ties in a network.

The `ties` data frame and the network `g` are already loaded in the workspace for your convenience.

INSTRUCTIONS

Build a Boolean vector named `weakness` that, for each tie, contains `TRUE` if the tie is weak (has weight equal to 1) and `FALSE` otherwise. Take advantage of function `E()` on the weight variable of the network.

Use `sum()` to check that weakness contains the correct number of weak ties (recall that there are 214 weak ties).

Visualize the network with `ggraph()` by setting the tie `color` to `weakness`.

```{r}
# build vector weakness containing TRUE for weak ties
weakness <- E(g)$weight <= 1

# check that weakness contains the correct number of weak ties
sum(weakness)

# visualize the network by coloring the weak and strong ties
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(color = weakness)) + 
  geom_node_point()
```

##Visualize the sub-network of weak ties

In this exercise, we will use `ggraph` again to visualize the sub-network containing only the weak ties. We will use the aesthetic `filter` to filter the ties.

The network `g` and the Boolean vector `weakness` are already loaded in the workspace for your convenience.

INSTRUCTIONS

Visualize the network with only weak ties using the `filter` aesthetic set to the weakness variable.

Set the global transparency, `alpha`, to 0.5 for all ties.

```{r}
# visualize the network with only weak ties using the filter aesthetic
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(filter = weakness), alpha = 0.5) + 
  geom_node_point()
```

##More on betweenness

Typically, only the shortest paths are considered in the definition of betweenness. However, there are a couple issues with this approach:

- All paths (even slightly) longer than the shortest ones are not considered.

- The actual number of shortest paths that lie between the two nodes is irrelevant.

In many applications, however, it is reasonable to consider both the quantity and the length of all paths of the network, since communication on the network is enhanced as soon as more routes are possible, particularly if these pathways are short.

Which of the following is not an issue of shortest path betweenness?

ANSWER THE QUESTION

Possible Answers (Correct Answer is **Bolded**)

Only optimal paths are considered.

The quantity of paths between nodes is not considered.

Paths longer than the shortest path are irrelevant.

**The computational complexity is prohibitive.**



#Chapter 3: Connection Patterns

The challenge in this chapter is to discover pairs of similar (and dissimilar) terrorists. We will introduce the adjacency matrix as a mathematical representation of a network and use it to find terrorists with similar connection patterns. We will also learn how to visualize similar and dissimilar pairs of individuals using ggraph.

##Visualizing connection patterns
We use a scatter plot to visualize the ties between nodes in a network. The idea is to draw a point in the plot at position (x, y) if there is a tie that connects the nodes x and y. We use different colors for the points to distinguish the connection weights.

The resulting visualization is useful to detect similar connection patterns. If two rows (or columns) of the plot are similar, then the two corresponding nodes have similar tie patterns to other nodes in the network.

The `ties` data frame is already loaded in the workspace.

INSTRUCTIONS 1/3

Mutate the `ties` data frame by swapping the variables `from` and `to` (use a temporary variable temp) and assign the result to `ties_mutated`

```{r}
# mutate ties data frame by swapping variables from and to 
ties_mutated <- mutate(ties, temp = to, to = from, from = temp) %>% select(-temp)
```


INSTRUCTIONS 2/3

Append the `ties_mutated` data frame to the `ties` data frame using the `rbind()` function and save it to `ties` 

```{r}
# append ties_mutated data frame to ties data frame
ties <- rbind(ties, ties_mutated)
```


INSTRUCTIONS 3/3

Use a scatter plot to visualize node connection patterns in `ties.` Set the color aesthetic to `weight`.

```{r}
# use a scatter plot to visualize node connection patterns in ties setting color aesthetic to weight
ggplot(ties, aes(x = from, y = to, color = factor(weight))) +
  geom_point() +
  labs(color = "weight")
```


##The adjacency matrix (part 1)

The adjacency matrix is a mathematical representation of a network. It is like a square table with rows and columns.

The cells of the matrix, called entries, are the intersection of rows and columns. For instance, entry (2,3) in the matrix corresponds to the cell at row 2 and column 3.

The encoding of the network in a matrix is as follows: we number each node with the integers from 1 to n, then we put a 1 in the entry if there is a tie between the x and y of the network, and we put a 0 if there is no tie.

INSTRUCTIONS

Get the weighted adjacency matrix of the network with the `as_adjacency_matrix()` function and assign it to the variable `A`

Print the first row and first column of `A`

Print a sub-matrix of the first 6 rows and columns of `A`. Is the matrix symmetric? Why?


```{r}
# get the weighted adjacency matrix
A <- as_adjacency_matrix(g, attr = "weight", sparse = FALSE, names = FALSE)

# print the first row and first column of A
A[1,]
A[,1]

# print submatrix of the first 6 rows and columns
A[1:6, 1:6]
```

##The adjacency matrix (part 2)

The adjacency matrix encodes the structure of the network, that is nodes and ties. It can be manipulated with matrix algebra operations to obtain useful insights about the network, including centrality measures.

In this exercise, we use the adjacency matrix to compute, once again, the node degrees and node strengths. The adjacency matrix `A` is loaded in the workspace.

INSTRUCTIONS

Obtain a vector of node strengths using the weighted adjacency matrix `A`
Build a Boolean matrix `B` from the weighted matrix `A`: a 1 entry in `B` corresponds to a positive entry in `B`, while a 0 entry in `B` corresponds to a 0 entry in `A`

Obtain a vector of node degrees using the Boolean matrix `B`

```{r}
# obtain a vector of node strengths
rowSums(A)

# build a Boolean (0/1) matrix from the weighted matrix A
B <- A > 0

# obtain a vector of node degrees using the Boolean matrix
rowSums(B)
```

##Computing Pearson similarity

In this exercise, we will explore Pearson similarity to find similarities between the nodes in the network.

The general idea is to associate each node with its column in the adjacency matrix. The similarity of two nodes is then measured as the Pearson correlation coefficient between the node columns.

Recall that the Pearson correlation coefficient runs from -1, or maximum dissimilarity, to 1, maximum similarity, and values close to 0 indicate no correlation, hence they are neither similar nor dissimilar.

INSTRUCTIONS

Use `cor()` to compute the Pearson correlation between the columns of the adjacency matrix `A` and save it to `S` 

Remove self similarity from `S` by setting the diagonal of `S` to 0 with `diag()`

Print a summary of the similarities in matrix `S` with `summary()`

Plot a histogram of the similarities in matrix `S` with `hist()`

```{r}
# compute the Pearson correlation on columns of A
S <- cor(A)

# set the diagonal of S to 0
diag(S) = 0

# print a summary of the similarities in matrix S
summary(c(S))

# plot a histogram of similarities in matrix S
hist(c(S), xlab = "Similarity", main = "Histogram of similarity")
```

##Negative and positive similarity

The similarity histogram we plotted in the previous exercise has a longer right tail, but also has a peak slightly below 0.

What is the percentage of node pairs having negative similarity? Use the console to find the answer.

The similarity matrix `S` is at your disposal. Proceed as follows:

Find negative entries by creating a Boolean matrix `S[S<0]`

Use `length()` to determine the number of negative entries and total entries in the matrix.

Divide the number of negative entries by the total number of entries in `S`.

INSTRUCTIONS

```{r}
neg <- S[S<0]

num_neg <- length(neg)
total <- length(S)

num_neg/total
```


Possible Answers (Correct answer is **Bolded**)

50%

**61%**

64%

37%


##Explore correlation between degree and strength

To review Pearson correlation, we correlate centrality measures degree and strength that we computed in the first chapter. Recall that the Pearson correlation coefficient runs from -1 (a perfect negative correlation) to 1 (a perfect positive correlation). Values close to 0 indicate no correlation.

Moreover, we use the `ggplot2` package to draw a scatterplot among degree and strength variables adding a regression line.

The data frame `nodes`, which contains the nodes of the network is at your disposal.

INSTRUCTIONS

Draw a scatter plot comparing the variables `degree` and `strength` of the `nodes` data frame.

In the same plot, add a regression line with the `geom_smooth` geometry.

Use `cor()` to compute the correlation between degree and strength in the nodes data frame. What kind of relationship do you observe?

```{r}
# Scatter plot of degree and strength with regression line
ggplot(nodes, aes(x = degree, y = strength)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)

# Pearson correlation coefficient 
cor(nodes$degree, nodes$strength)
```

##Tidy the similarity matrix

In this exercise, we tidy the similarity matrix into a similarity data frame. Using a similarity data frame is much more handy when analyzing and visualizing the similarities between nodes, as we will see in the following exercises.

We do this in two steps:

- First we convert the similarity matrix into a corresponding similarity network using `graph_from_adjacency_matrix()`

- Then we convert the similarity network into a similarity data frame using `as_data_frame()`

The similarity matrix `S` is at your disposal in the workspace.

INSTRUCTIONS 1/4

Build the weighted network associated with `S` and save it to `h`

```{r}
# build weighted similarity network and save to h
h <- graph_from_adjacency_matrix(S, mode = "undirected", weighted = TRUE)

```

INSTRUCTIONS 2/4

Convert the similarity network `h` into a similarity data frame `sim_df`

```{r}
# convert the similarity network h into a similarity data frame sim_df
sim_df <- igraph::as_data_frame(h, what = "edges")

#NOTE FROM NEIL: package conflict, must use igraph::as_data_frame, not dplyr. Definitely a good note to keep in mind when you are using tidyverse & igraph.
```



INSTRUCTIONS 3/4

Map the similarity data frame to a tibble and save it to `sim_tib`.

```{r}
# map the similarity data frame to a tibble and save it as sim_tib
sim_tib <- as_tibble(sim_df)
```


INSTRUCTIONS 4/4

Print `sim_tib` to look at the data in the console.

```{r}
# print sim_tib
sim_tib
```

##Join similarity and nodes data frames

The similarity data frame `sim` contains pairs of nodes and their similarities. The terrorist data frame nodes that we built in the previous lessons contains, for each terrorist, the name, degree, and strength.

Here we make use of `dplyr` to join these two data frames. The resulting data frame will contain named pairs of terrorists with their similarity score and the centrality measures, degree and strength.

The similarity data frame `sim` is loaded in the workspace for your convenience.

```{r, echo = FALSE}
sim <- sim_tib
```

INSTRUCTIONS

Join the `sim` and `nodes` data frames using `left_join()`

Print `sim2` to the console.

```{r}
# left join similarity and nodes data frames and then select and rename relevant variables
sim2 <- sim %>% 
  left_join(nodes, c("from" = "id")) %>% 
  left_join(nodes, c("to" = "id")) %>%
  select(from, to, name_from = name.x, name_to = name.y, similarity = weight, 
         degree_from = degree.x, degree_to = degree.y, strength_from = strength.x, strength_to = strength.y)
  
# print sim2
sim2

```

##Find most similar and dissimilar pairs

In this exercise, we use the similarity data frame `sim2` we built in the previous exercise, to discover the most similar and least similar pairs of terrorists.

We will also find the most similar and dissimilar pairs of terrorists in the pairs of central terrorists (those with a degree larger than the threshold).

INSTRUCTIONS 1/3

Arrange sim2 in decreasing order of similarity. Notice the degrees of the most similar pair.

```{r}
# arrange sim2 in decreasing order of similarity. 
sim2 %>% arrange(-similarity)
```


INSTRUCTIONS 2/3

Filter `sim2` allowing only pairs with a degree at >= 10.

Arrange the result in decreasing order of similarity. Which are the most similar terrorists?

```{r}
# filter sim2, allowing only pairs with a degree of least 10, arrange the result in decreasing order of similarity
sim2 %>%
  filter(degree_from >= 10, degree_to >= 10) %>%
  arrange(-similarity)
```


INSTRUCTIONS 3/3

Repeat the above steps, but this time arrange the terrorists in increasing order of similarity. Which are the least similar terrorists?

```{r}
# Repeat the previous steps, but in increasing order of similarity
sim2 %>%
  filter(degree_from >= 10, degree_to >= 10) %>%
  arrange(similarity)
```

##Visualize similarity

We are finally ready to visualize similarity as a network.

We will include only significant positive similarities, those with a score of at least 0.60 (recall that the maximum is 1). Next, we will use the `ggraph` package to visualize the filtered similarity network, where the nodes are terrorists and the ties connect similar pairs of terrorists.

Some clusters of similar nodes will emerge, that is, terrorist cells. Can you spot them? We will investigate similarity between clusters deeper in the next chapter.

The similarity data frame `sim2` is loaded in the workspace for your convenience.

INSTRUCTIONS

Filter the similarity data frame `sim2` allowing only similarities larger than or equal to 0.60. Save the result to `sim3`

Use `graph_from_data_frame()` to build a similarity network called `h2` from `sim3`

Use `ggraph()` to visualize the similarity network `h2`

Set tie transparency to similarity and use the Kamada-Kawai layout.

```{r}
# filter the similarity data frame to similarities larger than or equal to 0.60
sim3 <- filter(sim2, similarity >= 0.60)

# build a similarity network called h2 from the filtered similarity data frame
h2 <- graph_from_data_frame(sim3, directed = FALSE)

# visualize the similarity network h2
ggraph(h2, layout = "with_kk") + 
  geom_edge_link(aes(alpha = similarity)) + 
  geom_node_point()
```


#Chapter 4: Similarity clusters

In this chapter we will discover cells of similar terrorists. We will explore hierarchical clustering to find groups of similar terrorists building on the notion of similarity of connection patterns developed in the previous chapter. Furthermore, we will explore the visNetwork package to produce fulfilling interactive network visualizations.

##Cluster the similarity network

In this exercise, we will explore hierarchical clustering to find groups (clusters) of similar terrorists.

The basic idea behind hierarchical clustering is to define a measure of similarity between groups of nodes and then incrementally merge together the most similar groups of nodes until all nodes belongs to a unique cluster. The result of this process is called a *dendrogram*.

We will use Pearson similarity to determine similarity between nodes and extend it to find similarity between groups using the average-linkage strategy. The Pearson similarity matrix `S` is already loaded in the workspace.

INSTRUCTIONS

Compute a distance matrix `D` as the complement to 1 of `S`.

Obtain a distance object `d` from `D` using `as.dist()`.

Run the average-linkage clustering method `hclust()` on `d`, save the result to `cc`, and plot the dendrogram with `plot()`.

Find the similarity of the first pair of nodes that have been merged during clustering.

```{r}
# compute a distance matrix
D <- 1 - S

# obtain a distance object 
d <- as.dist(D)

# run average-linkage clustering method and plot the dendrogram 
cc <- hclust(d, method = "average")
plot(cc)

# find the similarity of the first pair of nodes that have been merged 
S[40, 45]
```


##Cut the dendrogram

In hierarchical clustering, each merge of groups of nodes happens sequentially (1, 2, 3, ...) until a unique group containing all nodes is formed.

A dendrogram is a tree structure where every node of the tree corresponds to a particular merging of two node groups in the clustering process. Hence, a dendrogram contains merging information of the entire clustering process.

Here, we freeze the state in which the nodes are grouped into 4 clusters and add the cluster information to the nodes dataset for future analysis. The dendrogram variable `cc` and the data frame `nodes` are loaded in the workspace.

INSTRUCTIONS

Use `cutree()` to cut the dendrogram in variable `cc` at 4 clusters and save the result to `cls`.

Use `mutate()` to add a cluster variable and set it to `cls`.

Print the `nodes` data frame and take a look at it.

```{r}
# cut the dendrogram at 4 clusters
cls <- cutree(cc, k = 4)

# add cluster information to the nodes data frame
nodes <- mutate(nodes, cluster = cls)

# print the nodes data frame
nodes
```


##Analyze clusters

We are finally ready to work on the clusters using the `dplyr` package. In particular, we will show how to select nodes in a given cluster and how to compute aggregate statistics on the node clusters.

The `nodes` dataset is ready in the workspace.

INSTRUCTIONS

Use `dplyr` verbs on the `nodes` data frame to output the names of terrorists in the first cluster.

Write a `dplyr` statement that outputs the size of the cluster, the average node degree, and the average node strength for each cluster.

Sort the result by cluster size.


```{r}
# output the names of terrorists in the first cluster
filter(nodes, cluster == 1) %>% 
    select(name)

# for each cluster select the size of the cluster, the average node degree, and the average node strength and sorts by cluster size
group_by(nodes, cluster) %>%
  summarise(size = n(), 
            avg_degree = mean(degree),
            avg_strength = mean(strength)) %>%
  arrange(-size)
```



##Visualize the clusters

Here we will use `ggraph` to visualize the original network using colored clusters and facet the visualization into four sub-networks, one for each terrorist cell or cluster.

The variable `g` that contains the network and the `nodes` data frame are loaded in the workspace.

INSTRUCTIONS 1/3

Add the cluster information in the variable `cluster` of the `nodes` data frame to a node attribute called `cluster` of network `g`.

```{r}
# add cluster information to the network 
V(g)$cluster <- nodes$cluster
```

INSTRUCTIONS 2/3

Use `ggraph` to visualize the original network with colored clusters.

```{r}
# visualize the original network with colored clusters
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight), show.legend=FALSE) + 
  geom_node_point(aes(color = factor(cluster))) +
  labs(color = "cluster")
```


INSTRUCTIONS 3/3

Use `ggraph` to facet the network with respect to cluster attribute.

```{r}

# facet the network with respect to cluster attribute
ggraph(g, layout = "with_kk") + 
  geom_edge_link(aes(alpha = weight), show.legend=FALSE) + 
  geom_node_point(aes(color = factor(cluster))) +
  facet_nodes(~cluster, scales="free")  +
  labs(color = "cluster")
```

##Basic visualization

In this final lesson, we will explore the `visNetwork` package to produce fulfilling interactive network visualizations.

With this package, it is possible to visualize networks, in particular `igraph` networks, and interact with them, by clicking, moving, zooming and much more.

In this first exercise, we will use basic steps to visualize and explore our terrorism network g, which is loaded in the workspace.

Make sure to enjoy the live networks by interacting with them: click on a node, move a node, move the entire network, zoom in and out!

INSTRUCTIONS 1/3

Use `toVisNetworkData()` to convert `g` to VisNetwork format.

```{r}
# convert igraph to visNetwork
data <- toVisNetworkData(g)
```

INSTRUCTIONS 2/3

Print the head of the nodes and edges of `data`.

```{r}
# print head of nodes and ties
head(data$nodes)
head(data$edges)
```



INSTRUCTIONS 3/3

Visualize the network with `visNetwork()` using the nodes and edges of `data`. Recall that edges is another word for ties.

```{r}
# convert igraph to visNetwork
data <- toVisNetworkData(g)

# print head of nodes and ties
head(data$nodes)
head(data$edges)

# visualize the network
visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300)
```


##Change the layout

It is possible to change the layout of the visualization using the `visNetwork()` and `visIgraphLayout()` function calls. Browse the `igraph` package by typing `?igraph` in the console to find out the names of the different layouts.

The `data` variable containing the `visNetwork` is loaded in the workspace.

INSTRUCTIONS 1/3

Change the layout of the network visualization using the Kamada-Kawai layout.

```{r}
# use the circle layout
visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visIgraphLayout(layout = "layout_with_kk")
```


INSTRUCTIONS 2/3

Layout in circle

```{r}
visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visIgraphLayout(layout = "layout_in_circle")
```


INSTRUCTIONS 3/3

Layout in grid

```{r}
# use the grid layout
visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visIgraphLayout(layout = "layout_on_grid")
```


##Highlight nearest nodes and ties

We can also add extra interaction features to our network. Here, we will highlight the nearest nodes and ties when a node is selected.

An interesting thing about `visNetwork` is the use of pipes (`%>%`), like in `dplyr` queries, to add extra layers to the visualization.

The `data` variable containing the `visNetwork` is loaded in the workspace.

INSTRUCTIONS

Use `visOptions()` with the parameter `highlightNearest` set to `TRUE` to highlight the nearest nodes and ties of the selected node.

After you run the solution, select a node. What changes?

```{r}
# highlight nearest nodes and ties of the selected node
visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visIgraphLayout(layout = "layout_with_kk") %>%
  visOptions(highlightNearest = TRUE) 
```


##Select nodes and groups of nodes

Finally, we will select nodes by their names and by the groups they belong to.

The group variable in the `nodes` data frame we used in the `visNetwork` representation contains information about which group a node belongs to and is used to select nodes by group. The function `toVisNetworkData()` converts an `igraph` network to a `visNetwork` and reads group information from the color attribute of the `igraph` network.

The data variable containing the `visNetwork` and the network `g` are loaded in the workspace.

INSTRUCTIONS 1/2

Use `visOptions()` with the parameter `nodesIdSelection` set to `TRUE` to select nodes by id.


```{r}
# select nodes by id 
visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visIgraphLayout(layout = "layout_with_kk") %>%
  visOptions(nodesIdSelection = TRUE)
```


INSTRUCTIONS 2/2

Set `V(g)$color` to `cluster`, call `toVisNetworkData()` on `g`, and set `selectedBy` in `visOptions()` to group.

```{r}
# set color to cluster and generate network data
V(g)$color = V(g)$cluster
data <- toVisNetworkData(g)

# select by group (cluster)
visNetwork(nodes = data$nodes, edges = data$edges, width = 300, height = 300) %>%
  visIgraphLayout(layout = "layout_with_kk") %>%
  visOptions(selectedBy = "group")
```


