---
title: "Joining Data in R with dplyr"
subtitle: Lessons from DataCamp
output:
  html_document:
    toc: yes
    toc_float: true
  html_notebook:
    toc: yes
    toc_float: true
  pdf_document:
    toc: yes
    toc_depth: 3
---

#Introduction

The following document outlines the written portion of the lessons from [DataCamp](https://www.datacamp.com/)'s [Joining Data in R with dplyr](https://www.datacamp.com/courses/joining-data-in-r-with-dplyr). This requires Intermediate R-Knowledge and understanding of the dplyr package.

As a note: All text is completely copied and pasted from the course. There are instances where the document refers to the "editor on the right", please note, that in this notebook document all of the instances are noted in the "r-chunks" (areas containing working r-code), which occurs below the text, rather than to the right. Furthermore, This lesson contained instructional videos at the beginning of new concepts that are not detailed in this document. However, even without these videos, the instructions are quite clear in indicating what the code is accomplishing. 

<u>*If you have this document open on "R-Notebook", simply click "run" -> "Run all" (Or just press 'ctrl + alt + r'), let the "r-chunks" run (This might take a bit of time) then click "Preview". There are 5 necessary datasets to run this program, please create an r-project with this data or set a working directory (required files names are available in the "Required data for this session" section)*</u>

This document was created by Neil Yetz on 08/08/2018. Please send any questions or concerns in this document to Neil at <ndyetz@gmail.com>



##Required packages for this session

Below are the install.packages and libraries you will need to have in order to run this session successfully.

```{r, message = FALSE}
library(readr)
library(dplyr)

```

##Required data for this session

```{r, message = FALSE, warning = FALSE, results = 'hide'}

setwd("Data/")

#read all .csv files
temp = list.files(pattern="*.csv")
list2env(
  lapply(setNames(temp, make.names(gsub("*.csv$", "", temp))), 
         read_csv), envir = .GlobalEnv)
rm(temp)


#load R files
eighties <- readRDS("eighties.RDS")
lahmanNames <- readRDS("lahmanNames.RDS")
seventies <- readRDS("seventies.RDS")



```

#Course Description

This course builds on what you learned in Data Manipulation in R with dplyr by showing you how to combine data sets with dplyr's two table verbs. In the real world, data comes split across many data sets, but dplyr's core functions are designed to work with single tables of data. In this course, you'll learn the best ways to combine data sets into single tables. You'll learn how to augment columns from one data set with columns from another with mutating joins, how to filter one data set against another with filtering joins, and how to sift through data sets with set operations. Along the way, you'll discover the best practices for building data sets and troubleshooting joins with dplyr. Afterwards, youâ€™ll be well on your way to data manipulation mastery!

#Chapter 1: Mutating joins

Mutating joins add new variables to one dataset from another dataset, matching observations across rows in the process. This chapter will explain the various ways you can join datasets together and what happens when you do.


##A basic join
As Garrett mentioned in the video, left_join() is the basic join function in dplyr. You can use it whenever you want to augment a data frame with information from another data frame.

For example, left_join(x, y) joins y to x. The second dataset you specify is joined to the first dataset. Keep that in mind as you go through the course.

For this exercise, the code in the editor sets up a left join but doesn't finish it. It's up to you to complete it.

INSTRUCTIONS

Complete the code to join artists to bands. bands2 should contain all of the information in bands supplemented with information in artists.

Print bands2 to the console to see the result.

```{r}
# Complete the code to join artists to bands
bands2 <- left_join(bands, artists, by = c("first", "last"))

# Examine the results
bands2
```


##A second join
You should always check the output of your joins. Just because a join worked, doesn't mean that it worked as you expected.

For example, the code in the editor joins the same two datasets that you joined in the previous exercise, but it returns a different result. Can you tell what went wrong?

INSTRUCTIONS

The result from the previous exercise, bands2, is loaded in your workspace.

Examine the output from the code provided in the editor. How is it different from bands2?
Fix the code so that the result is identical to bands2.

```{r}
# Fix the code to recreate bands2
left_join(bands, artists, by = c("first", "last"))
```

##A right join
There is more than one way to execute a left join. Knowing multiple methods will make you a more versatile data scientist, especially as you try to fit joins into pipes created with %>%.

In this exercise, you'll recreate bands2 once more, but this time without using a left_join().

INSTRUCTIONS

Use right_join() to create bands3, a new dataset that contains the same information as bands2.
Use setequal() to check that the datasets are the same.

```{r}
# Finish the code below to recreate bands3 with a right join
bands2 <- left_join(bands, artists, by = c("first", "last"))
bands3 <- right_join(artists, bands, by = c("first", "last"))

# Check that bands3 is equal to bands2
setequal(bands2, bands3)
```


##Inner joins and full joins
You may have noticed that some of the songs in songs correspond to some of the albums in albums. Suppose you want a new dataset that contains all of the songs for which you have data from both albums and songs. How would you make it?

The artists and bands datasets also share some information. What if you want to join these two datasets in such a way that you retain all of the information available in both tables, without throwing anything away?

You can think of inner joins as the most strict type of join: they only retain observations that appear in both datasets. In contrast, full joins are the most permissive type of join: they return all of the data that appears in both datasets (often resulting in many missing values).

Recall that, *_join(x, y) joins y to x. The second dataset you specify is joined to the first dataset.

INSTRUCTIONS

Join albums to songs in a way that returns only rows that contain information about both songs and albums.
Join bands to artists to create a single table that contains all of the available data.

```{r}
# Join albums to songs using inner_join()
inner_join(songs, albums, by = "album")

# Join bands to artists using full_join()
full_join(artists, bands, by = c("first", "last"))
```

##Pipes
You can combine dplyr functions together with the pipe operator, %>%, to build up an analysis step-by-step. %>% takes the result of the code that comes before it and "pipes" it into the function that comes after it as the first argument of the function.

So for example, the two pieces of code below do the same thing:

```
full_join(artists, bands, 
          by = c("first", "last"))

artists %>% 
  full_join(bands, by = c("first", "last"))
```
  
Pipes are so efficient for multi-step analysis that you will use them for the remainder of the exercises in this course. (If you need a refresher on the pipe operator, check out Data Manipulation in R with dplyr course!)

INSTRUCTIONS

The code in the editor finds all of the known guitarists in the bands dataset. Rewrite the code to use %>%s instead of multiple function calls. The pipe %>% should be used three times and temp zero times.


```{r}
# Find guitarists in bands dataset (don't change)
temp <- left_join(bands, artists, by = c("first", "last"))
temp <- filter(temp, instrument == "Guitar")
select(temp, first, last, band)

# Reproduce code above using pipes
bands %>% 
  left_join(artists, by = c("first", "last")) %>%
  filter(instrument == "Guitar") %>%
  select(first, last, band)
```


```{r, echo = FALSE}
#Ignore
goal <- artists %>%
  full_join(bands, by = c("first", "last")) %>%
  inner_join(songs, by = c("first", "last"))
```


##Practice with pipes and joins
We've created a data frame for you called goal. It's available in your workspace, so go ahead and take a look. Your mission, if you choose to accept it, is to create a dataset that's identical to goal.

INSTRUCTIONS

Examine the goal dataset by printing it to the console.
Write a pipe that uses a full join and an inner join to combine artists, bands, and songs into goal2, a dataset identical to goal.
Use setequal() to check that goal is identical to goal2.

```{r}
# Examine the contents of the goal dataset
goal

# Create goal2 using full_join() and inner_join() 
goal2 <- artists %>%
  full_join(bands, by = c("first", "last")) %>%
  inner_join(songs, by = c("first", "last"))
  
  
  
# Check that goal and goal2 are the same
setequal(goal, goal2)
```

##Choose your joins
You're getting the hang of pipes now! They are a very useful way to combine multiple joins to make a single dataset.

Let's craft one more dataset before moving to Chapter 2. One of the most useful ways to combine data is to place all of the values of all of the datasets into a single table.

INSTRUCTIONS

Write a pipe that combines artists, bands, songs, and albums (in that order) into a single table, such that it contains all of the information in the datasets.

```{r}
# Create one table that combines all information
artists %>%
  full_join(bands,  by = c("first", "last")) %>%
  full_join(songs,  by = c("first", "last")) %>%
  full_join(albums, by = c("album", "band"))
```



#Chapter 2: Filtering joins and set operations

Filtering joins and set operations combine information from datasets without adding new variables. Filtering joins filter the observations of one dataset based on whether or not they occur in a second dataset. Set operations use combinations of observations from both datasets to create a new dataset.

##Apply a semi-join
As you saw in the video, semi-joins provide a concise way to filter data from the first dataset based on information in a second dataset.

For example, the code in the editor uses semi_join() to create a data frame of the artists in artists who have written a song in songs.

INSTRUCTIONS

Run the semi_join() command to see its output.
Then fill in the blanks of the right_join(), filter(), and select() calls to create the same result.

```{r}

# View the output of semi_join()
artists %>% 
  semi_join(songs, by = c("first", "last"))

# Create the same result
artists %>% 
  right_join(songs, by = c("first", "last")) %>% 
  filter(!is.na(instrument)) %>% 
  select(first, last, instrument)


```

##Exploring with semi-joins

Semi-joins provide a useful way to explore the connections between multiple tables of data.

For example, you can use a semi-join to determine the number of albums in the albums dataset that were made by a band in the bands dataset.

INSTRUCTIONS

For the first pipe, use semi_join() to collect the albums in albums that were made by a band in bands.
For the second pipe, use nrow() to count how many albums were made by a band in the dataset.

```{r}
albums %>% 
  # Collect the albums made by a band
    semi_join(bands, by = "band") %>% 
  # Count the albums made by a band
  nrow()
```

##Apply an anti-join

As Garrett mentioned in the video, anti-joins provide a useful way to reason about how a mutating join will work before you apply the join.

For example, you can use an anti-join to see which rows will not be matched to a second dataset by a join.

INSTRUCTIONS

Use an anti_join() to return the rows of artists for which you don't have any bands info. Note: Don't forget to mention the by argument.

```{r}
# Return rows of artists that don't have bands info
artists %>% 
  anti_join(bands, by = c("first", "last"))
```


##Apply another anti-join
Anti-joins with anti_join() also provide a great way to diagnose joins that go wrong.

For example, they can help you zero-in on rows that have capitalization or spelling errors in the keys. These things will make your primary and secondary keys appear different to R, even though you know they refer to the same thing.

INSTRUCTIONS

labels describes the record labels of the albums in albums. Compare the spellings of album names in labels with the names in albums. Are any of the album names of labels mis-entered? Use anti_join() to check. Note: Don't forget to mention the by argument.

```{r}
# Check whether album names in labels are mis-entered
labels %>% 
  anti_join(albums, by = "album")
```

##Which filtering join?
Think you have filtering joins down? Let's check.

Which filtering join would you use to determine how many rows in songs match a label in labels?

INSTRUCTIONS

Determine which key joins labels and songs.
Use a filtering join to find the rows of songs that match a row in labels.
Use nrow() to determine how many matches exist between labels and songs.


```{r}
# Determine which key joins labels and songs
labels
songs

# Check your understanding
songs %>% 
  # Find the rows of songs that match a row in labels
  semi_join(labels, by = "album") %>% 
  # Number of matches between labels and songs
  nrow()
```


##How many songs are there?
We have loaded two datasets in your workspace, aerosmith and greatest_hits, each of which represents an album from the band Aerosmith. Each row in either of the datasets is a song on that album.

How many unique songs do these two albums contain in total?

INSTRUCTIONS

Use a set operation to create a dataset with every song contained on aerosmith and/or greatest_hits.
Use nrow() to count the total number of songs.


```{r}
aerosmith %>% 
  # Create the new dataset using a set operation
  union(greatest_hits) %>% 
  # Count the total number of songs
  nrow()
```

##Greatest hits

Which songs from Aerosmith made it onto Greatest Hits?

INSTRUCTIONS

Use a set operation to create a dataset containing every track that is in both Aerosmith and Greatest Hits.

```{r}
# Create the new dataset using a set operation
aerosmith %>% 
  intersect(greatest_hits)
```

##Live! Bootleg songs

live contains the songs from a third Aerosmith album, Live! Bootleg.

Which songs are on Live! Bootleg but not on Greatest Hits? Notice that the length of songs may be different when they are performed live.

INSTRUCTIONS

Select just the song names from live.

Select just the song names from greatest_hits.

Use a set operation to create a dataset of songs in live that are not in greatest_hits.

```{r}
# Select the song names from live
live_songs <- live %>% select(song)

# Select the song names from greatest_hits
greatest_songs <- greatest_hits %>% select(song)

# Create the new dataset using a set operation
live_songs %>% 
  setdiff(greatest_songs)
```


##Multiple operations

There is no set operation to find rows that appear in one data frame or another, but not both. However, you can accomplish this by combining set operators, as Garrett showed in the video.

Can you think of a combination that would answer the question, "Which songs appear on one of Live! Bootleg or Greatest Hits, but not both?"

INSTRUCTIONS

Select the songs from the live and greatest_hits datasets and call them live_songs and greatest_songs, respectively. Use the select() function to do this.
Combine setdiff(), union(), and intersect() to return all of the songs that are in one of live_songs or greatest_songs, but not both. You will need to use all three functions and save some results along the way (i.e. you won't be able to do this with a single pipe.)

```{r}
# Select songs from live and greatest_hits
live_songs <- select(live, song)
greatest_songs <- select(greatest_hits, song)

# Return the songs that only exist in one dataset
all_songs <- union(live_songs, greatest_songs)
both_songs <- intersect(live_songs, greatest_songs)
one_songs <- setdiff(all_songs, both_songs)
one_songs
  
```


##Apply setequal

definitive and complete contain the songs that appear in competing Led Zeppelin anthologies: The Definitive Collection and The Complete Studio Recordings, respectively.

Both anthologies claim to contain the complete studio recordings of Led Zeppelin, but do the anthologies contain the same exact songs?

INSTRUCTIONS

Use identical() to determine whether definitive and complete contain the same songs in the same order.
Use setequal() to determine whether definitive and complete contain the same songs in any order.
Use setdiff() to see which songs (if any) are in definitive but not complete.
Use setdiff() to see which songs (if any) are in complete but not definitive.

```{r}
# Check if same order: definitive and complete
identical(definitive, complete)

# Check if any order: definitive and complete
setequal(definitive, complete)

# Songs in definitive but not complete
setdiff(definitive, complete)


# Songs in complete but not definitive
setdiff(complete, definitive)

```


##Apply setequal again
A few exercises ago, you saw that an intersect() is analagous to a semi_join() when two datasets contain the same variables and each variable is used in the key.

Under these conditions, setdiff() is also analagous to one of the filtering joins.

INSTRUCTIONS

Write a filtering join that returns songs in definitive that are not in complete. Are there any?
Write a filtering join that returns songs in complete that are not in definitive. Are there any?

```{r}
# Return songs in definitive that are not in complete
definitive %>% 
  anti_join(complete, by = c("song", "album"))

# Return songs in complete that are not in definitive
complete %>% 
  anti_join(definitive, by = c("song", "album"))
```

##Comparing albums
It appears that The Definitive Collection contains songs from the soundtrack of The Song Remains the Same, a movie filmed during a live Led Zeppelin concert. Is this the only difference between The Definitive Collection and The Complete Studio Recordings?

INSTRUCTIONS

The songs from The Song Remains the Same are contained in soundtrack.

Use identical() to check if definitive and the union of complete and soundtrack contain the same songs in the same order.
Use setequal() to check if definitive and the union of complete and soundtrack contain the same songs in any order.

```{r}
# Check if same order: definitive and union of complete and soundtrack
identical(definitive, union(complete, soundtrack))



# Check if any order: definitive and union of complete and soundtrack
setequal(definitive, union(complete, soundtrack))


```


#Chapter 3: Assembling data

This chapter will show you how to build datasets from basic elements: vectors, lists, and individual datasets that do not require a join. dplyr contains a set of functions for assembling data that work more intuitively than base R's functions. The chapter will also look at when dplyr does and does not use data type coercion.

##Which bind?
side_one and side_two contain tracks from sides one and two, respectively, of Pink Floyd's famous album The Dark Side of the Moon.

Bind these datasets into a single table using a dplyr function. Which type of bind should you use?

INSTRUCTIONS

Examine side_one and side_two by printing them to the console.
Use a bind to combine side_one and side_two into a single dataset.

```{r}
# Examine side_one and side_two
side_one
side_two

# Bind side_one and side_two into a single dataset
side_one %>% 
  bind_rows(side_two)
```

##Bind rows

discography and jimi contain all of the information you need to create an anthology dataset for the band The Jimi Hendrix Experience.

discography contains a data frame of each album by The Jimi Hendrix Experience and the year of the album.

jimi contains a list of data frames of album tracks, one for each album released by The Jimi Hendrix Experience. As Garrett explained in the video, you can pass bind_rows() a list of data frames like jimi to bind together into a single data frame.

INSTRUCTIONS

Examine discography and jimi.
Bind jimi into a single data frame. As you do, save the data frame names as a column named album by specifying the .id argument to bind_rows().
Left join discography to the results to make a complete data frame.
```{r, echo = FALSE}
jimi <- list(`Are You Experienced` = jimi1 , `Axis: Bold As Love` = jimi2, `Electric Ladyland` = jimi3)
```

```{r}
# Examine discography and jimi
discography
jimi

jimi %>% 
  # Bind jimi into a single data frame
  bind_rows(.id = "album") %>% 
  # Make a complete data frame
  left_join(discography, by = "album")
```


##Bind columns
Let's make a compilation of Hank Williams' 67 singles. To do this, you can use hank_years and hank_charts:

hank_years contains the name and release year of each of Hank Williams' 67 singles.
hank_charts contains the name of each of Hank Williams' 67 singles as well as the highest position it earned on the Billboard sales charts.
Each dataset contains the same songs, but hank_years is arranged chronologically by year, while hank_charts is arranged alphabetically by song title.

INSTRUCTIONS

Examine hank_years and hank_charts. How should you bind the two datasets?
Use arrange() to reorder hank_years alphabetically by song title.
Select just the year column of the result.
Bind the year column to hank_charts.
arrange() the resulting dataset chronologically by year, then alphabetically by song title within each year.

```{r}
# Examine hank_years and hank_charts
hank_years
hank_charts

hank_years %>% 
  # Reorder hank_years alphabetically by song title
  arrange(song) %>% 
  # Select just the year column
  select(year) %>% 
  # Bind the year column
  bind_cols(hank_charts) %>% 
  # Arrange the finished dataset
  arrange(year)
```


##Make a data frame
Let's make a Greatest Hits compilation for Hank Williams. hank_year, hank_song, and hank_peak contain the columns of the data frame you made in the last exercise.

INSTRUCTIONS

Use data_frame() to combine hank_year, hank_song, and hank_peak into a data frame that has the column names year, song, and peak; in that order.
Use filter() to extract just the songs where peak equals 1 (i.e. Hank's number one hits.)

```{r, echo = FALSE}
hank_year <- hank_years %>% select(year);hank_song <- hank_charts %>% select(song);hank_peak <- hank_charts %>% select(peak)
hank_year <- as.vector(as.matrix(hank_year));hank_song<- as.vector(as.matrix(hank_song));hank_peak <- as.vector(as.matrix(hank_peak))

hank <- list(year = hank_year, song = hank_song, peak = hank_peak)
```


```{r}
# Make combined data frame using data_frame()
data_frame(year = hank_year, 
           song = hank_song, 
           peak = hank_peak) %>% 
  # Extract songs where peak equals 1
  filter(peak == 1)
```



##Lists of columns
As a data scientist, you should always be prepared to handle raw data that comes in many different formats.

hank saves Hank Williams' singles in a different way, as a list of vectors. Can you turn hank into the same dataset that you made in the last exercise?

INSTRUCTIONS

Examine the contents of hank.
Use as_data_frame() to convert the hank list into a data frame.
Use filter to extract the number one hits.

```{r}
# Examine the contents of hank
hank

# Convert the hank list into a data frame
as_data_frame(hank) %>% 
  # Extract songs where peak equals 1
  filter(peak == 1)
```

##Lists of rows (data frames)
michael contains a list of data frames, one for each album released by Michael Jackson. The code in the editor attempts to bind the data frames into a single data frame and then extract a data frame of the top tracks on each album.

However, the code runs into a problem. The commented line fails because as_data_frame() combines a list of column vectors into a data frame. However, michael is a list of data frames.

Can you fix the code? After all, you have seen something like this before.

INSTRUCTIONS

Examine the contents of michael.
Replace the commented code in the editor with a call to a dplyr function, which should bind the datasets in the list into a single data frame, adding an album column as it does.


```{r}
#Note from Neil: Do not have the "michael" list of dataframes

# Examine the contents of michael
#michael
#
#  bind_rows(michael, .id = "album") %>% 
#  group_by(album) %>% 
#  mutate(rank = min_rank(peak)) %>% 
#  filter(rank == 1) %>% 
#  select(-rank, -peak)
```



##Results
sixties contains the top selling albums in the US in the 1960s. It stores year as a numeric (double). When you combine it with seventies, which stores year as a factor, bind_rows() returns an error.

You can fix this by coercing seventies$year to a numeric. But if you do it like this, something surprising happens.

```
seventies %>% 
  mutate(year = as.numeric(year))
```
  
Can you fix things?

INSTRUCTIONS

Coerce seventies$year into a useful numeric.
Bind the updated version of seventies to sixties and examine the results. Make sure they are sensible.

```{r}
seventies %>% 
  # Coerce seventies$year into a useful numeric
  mutate(year = as.numeric(as.character(year))) %>% 
  # Bind the updated version of seventies to sixties
  bind_rows(sixties) %>% 
  arrange(year)
```



#Chapter 4: Advanced joining

Now that you have the basics, let's dive deep into the mechanics of joins. This chapter will show you how to spot common join problems, how to join based on multiple or mismatched keys, how to join multiple tables, and how to recreate dplyr's joins with SQL and base R.


#Chapter 5: Case study

You know the ins and outs of two-table verbs with dplyr, but your knowledge is untried! Let's cement what you've learned with a real world application.




